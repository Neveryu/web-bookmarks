(window.webpackJsonp=window.webpackJsonp||[]).push([[185],{626:function(s,e,a){"use strict";a.r(e);var t=a(10),v=Object(t.a)({},(function(){var s=this,e=s._self._c;return e("ContentSlotsDistributor",{attrs:{"slot-key":s.$parent.slotKey}},[e("h1",{attrs:{id:"vue"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue"}},[s._v("#")]),s._v(" Vue")]),s._v(" "),e("h2",{attrs:{id:"要点"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#要点"}},[s._v("#")]),s._v(" 要点")]),s._v(" "),e("p",[e("font",{attrs:{color:"red"}},[s._v("1、在 Vue 项目中，Vue 的版本号一定是要和我们的 "),e("code",[s._v("vue-template-compiler")]),s._v(" 的版本号一致。")])],1),s._v(" "),e("p",[s._v("2、Vue 打包后的文件分别是什么意思：")]),s._v(" "),e("ul",[e("li",[e("code",[s._v("mainifest.js")]),s._v("  ——  静态资源清单")]),s._v(" "),e("li",[e("code",[s._v("vendor.js")]),s._v("  —— "),e("code",[s._v("node_modules")]),s._v(" 里面的包打包出来的")]),s._v(" "),e("li",[e("code",[s._v("app.js")]),s._v(" —— 源码打包出来的")])]),s._v(" "),e("h2",{attrs:{id:"vue-中使用-css-预处理器"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#vue-中使用-css-预处理器"}},[s._v("#")]),s._v(" Vue 中使用 CSS 预处理器")]),s._v(" "),e("blockquote",[e("p",[s._v("node-sass 的下载总是不稳定，推荐使用 stylus")])]),s._v(" "),e("h3",{attrs:{id:"stylus"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#stylus"}},[s._v("#")]),s._v(" Stylus")]),s._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" i stylus stylus-loader "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-D")]),s._v("\n")])])]),e("h3",{attrs:{id:"sass"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#sass"}},[s._v("#")]),s._v(" Sass")]),s._v(" "),e("div",{staticClass:"language-bash extra-class"},[e("pre",{pre:!0,attrs:{class:"language-bash"}},[e("code",[e("span",{pre:!0,attrs:{class:"token function"}},[s._v("npm")]),s._v(" i node-sass sass-loader "),e("span",{pre:!0,attrs:{class:"token parameter variable"}},[s._v("-D")]),s._v("\n")])])]),e("h2",{attrs:{id:"为-vue-实例添加属性"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#为-vue-实例添加属性"}},[s._v("#")]),s._v(" 为 Vue 实例添加属性")]),s._v(" "),e("p",[s._v("前期采用 vue-resource，后期改为 axios，方便修改，因此写了： "),e("code",[s._v("Vue.prototype.$http = axios;")]),s._v("\n上面这句话是什么意思呢？\n意思就给全局设置了一个变量 $http 值是 axios。")]),s._v(" "),e("h2",{attrs:{id:"模式一"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#模式一"}},[s._v("#")]),s._v(" 模式一")]),s._v(" "),e("p",[s._v("用户登录成功之后，我们会在全局钩子 "),e("code",[s._v("router.beforeEach")]),s._v(" 中拦截路由，判断是否已获得 "),e("code",[s._v("token")]),s._v("，在获得 "),e("code",[s._v("token")]),s._v(" 之后，我们就要去获取用户的基本信息了。")]),s._v(" "),e("p",[s._v("就如前面所说的，我只在本地存储了一个用户的 "),e("code",[s._v("token")]),s._v("，并没有存储别的用户信息（如用户权限，用户名，用户头像等）。有些人会问为什么不把一些其它的用户信息也存一下？主要出于如下的考虑：")]),s._v(" "),e("p",[s._v("假设我把用户权限和用户名也存在了本地，但我这时候用另一台电脑登录修改了自己的用户名，之后再用这台存有之前用户信息的电脑登录，它默认会去读取本地 "),e("code",[s._v("cookie")]),s._v(" 中的名字，并不会去拉去新的用户信息。")]),s._v(" "),e("p",[s._v("所以现在的策略是：页面会先从 "),e("code",[s._v("cookie")]),s._v(" 中查看是否存有 "),e("code",[s._v("token")]),s._v("，没有，就走一遍上一部分的流程重新登录，如果有 "),e("code",[s._v("token")]),s._v("，就会把这个 "),e("code",[s._v("token")]),s._v("返给后端去拉取 "),e("code",[s._v("user_info")]),s._v("，保证用户信息是最新的。\n当然如果是做了单点登录得功能的话，用户信息存储在本地也是可以的。当你一台电脑登录时，另一台会被提下线，所以总会重新登录获取最新的内容。")]),s._v(" "),e("blockquote",[e("p",[s._v("而且从代码层面我建议还是把 "),e("code",[s._v("login")]),s._v(" 和 "),e("code",[s._v("get_user_info")]),s._v(" 两件事分开比较好，在这个后端全面微服务的年代，后端同学也想写优雅的代码~")])])])}),[],!1,null,null,null);e.default=v.exports}}]);