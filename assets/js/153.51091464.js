(window.webpackJsonp=window.webpackJsonp||[]).push([[153],{588:function(v,_,e){"use strict";e.r(_);var t=e(10),c=Object(t.a)({},(function(){var v=this,_=v._self._c;return _("ContentSlotsDistributor",{attrs:{"slot-key":v.$parent.slotKey}},[_("h1",{attrs:{id:"vite"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#vite"}},[v._v("#")]),v._v(" Vite")]),v._v(" "),_("blockquote",[_("p",[v._v("从 Vite 的诞生背景了解现在前端打包面临的问题。")])]),v._v(" "),_("h3",{attrs:{id:"现实问题"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#现实问题"}},[v._v("#")]),v._v(" 现实问题")]),v._v(" "),_("p",[v._v("在浏览器支持 "),_("code",[v._v("ES")]),v._v(" 模块之前，"),_("code",[v._v("JavaScript")]),v._v(" 并没有提供原生机制让开发者以模块化的方式进行开发。这也正是我们对 “打包” 这个概念熟悉的原因：使用工具抓取、处理并将我们的源码模块串联成可以在浏览器中运行的文件。")]),v._v(" "),_("p",[v._v("时过境迁，我们见证了诸如 "),_("code",[v._v("webpack")]),v._v("、 "),_("code",[v._v("Rollup")]),v._v(" 和 "),_("code",[v._v("Parcel")]),v._v(" 等工具的变迁，它们极大地改善了前端开发者的开发体验。")]),v._v(" "),_("p",[v._v("然而，当我们开始构建越来越大型的应用时，需要处理的 "),_("code",[v._v("JavaScript")]),v._v(" 代码量也呈指数级增长。包含数千个模块的大型项目相当普遍。我们开始遇到性能瓶颈 —— 使用 "),_("code",[v._v("JavaScript")]),v._v(" 开发的工具通常需要很长时间（甚至是几分钟！）才能启动开发服务器，即使使用 "),_("code",[v._v("HMR")]),v._v("，文件修改后的效果也需要几秒钟才能在浏览器中反映出来。如此循环往复，迟钝的反馈会极大地影响开发者的开发效率和幸福感。")]),v._v(" "),_("p",[_("code",[v._v("Vite")]),v._v(" 旨在利用生态系统中的新进展解决上述问题：浏览器开始原生支持 "),_("code",[v._v("ES")]),v._v(" 模块，且越来越多 "),_("code",[v._v("JavaScript")]),v._v(" 工具使用编译型语言编写。")]),v._v(" "),_("h3",{attrs:{id:"缓慢的服务器启动"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓慢的服务器启动"}},[v._v("#")]),v._v(" 缓慢的服务器启动")]),v._v(" "),_("p",[v._v("当冷启动开发服务器时，基于打包器的方式启动必须优先抓取并构建你的整个应用，然后才能提供服务。")]),v._v(" "),_("p",[_("code",[v._v("Vite")]),v._v(" 通过在一开始将应用中的模块区分为 "),_("strong",[v._v("依赖")]),v._v(" 和 "),_("strong",[v._v("源码")]),v._v(" 两类，改进了开发服务器启动时间。")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("依赖")]),v._v(" 大多为在开发时不会变动的纯 "),_("code",[v._v("JavaScript")]),v._v("。一些较大的依赖（例如有上百个模块的组件库）处理的代价也很高。依赖也通常会存在多种模块化格式（例如 "),_("code",[v._v("ESM")]),v._v(" 或者 "),_("code",[v._v("CommonJS")]),v._v("）。")])]),v._v(" "),_("p",[_("code",[v._v("Vite")]),v._v(" 将会使用 "),_("code",[v._v("esbuild")]),v._v(" 预构建依赖。"),_("code",[v._v("Esbuild")]),v._v(" 使用 "),_("code",[v._v("Go")]),v._v(" 编写，并且比以 "),_("code",[v._v("JavaScript")]),v._v(" 编写的打包器预构建依赖快 "),_("code",[v._v("10-100")]),v._v(" 倍。")]),v._v(" "),_("ul",[_("li",[_("strong",[v._v("源码")]),v._v(" 通常包含一些并非直接是 "),_("code",[v._v("JavaScript")]),v._v(" 的文件，需要转换（例如 "),_("code",[v._v("JSX")]),v._v("，"),_("code",[v._v("CSS")]),v._v(" 或者 "),_("code",[v._v("Vue/Svelte")]),v._v(" 组件），时常会被编辑。同时，并不是所有的源码都需要同时被加载（例如基于路由拆分的代码模块）。")])]),v._v(" "),_("p",[_("code",[v._v("Vite")]),v._v(" 以 原生 "),_("code",[v._v("ESM")]),v._v(" 方式提供源码。这实际上是让浏览器接管了打包程序的部分工作： "),_("code",[v._v("Vite")]),v._v(" 只需要在浏览器请求源码时进行转换并按需提供源码。根据情景动态导入代码，即只在当前屏幕上实际使用时才会被处理。")]),v._v(" "),_("p",[_("img",{attrs:{src:"https://cn.vitejs.dev/assets/bundler.37740380.png",alt:""}}),v._v(" "),_("img",{attrs:{src:"https://cn.vitejs.dev/assets/esm.3070012d.png",alt:""}})]),v._v(" "),_("h3",{attrs:{id:"缓慢的更新"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#缓慢的更新"}},[v._v("#")]),v._v(" 缓慢的更新")]),v._v(" "),_("p",[v._v("基于打包器启动时，重建整个包的效率很低。原因显而易见：因为这样更新速度会随着应用体积增长而直线下降。")]),v._v(" "),_("p",[v._v("一些打包器的开发服务器将构建内容存入内存，这样它们只需要在文件更改时使模块图的一部分失活[1]，但它也仍需要整个重新构建并重载页面。这样代价很高，并且重新加载页面会消除应用的当前状态，所以打包器支持了动态模块热重载（"),_("code",[v._v("HMR")]),v._v("）：允许一个模块 “热替换” 它自己，而不会影响页面其余部分。这大大改进了开发体验 —— 然而，在实践中我们发现，即使采用了 "),_("code",[v._v("HMR")]),v._v(" 模式，其热更新速度也会随着应用规模的增长而显著下降。")]),v._v(" "),_("p",[v._v("在 "),_("code",[v._v("Vite")]),v._v(" 中，"),_("code",[v._v("HMR")]),v._v(" 是在原生 "),_("code",[v._v("ESM")]),v._v(" 上执行的。当编辑一个文件时，"),_("code",[v._v("Vite")]),v._v(" 只需要精确地使已编辑的模块与其最近的 "),_("code",[v._v("HMR")]),v._v(" 边界之间的链失活[1]（大多数时候只是模块本身），使得无论应用大小如何，"),_("code",[v._v("HMR")]),v._v(" 始终能保持快速更新。")]),v._v(" "),_("p",[_("code",[v._v("Vite")]),v._v(" 同时利用 "),_("code",[v._v("HTTP")]),v._v(" 头来加速整个页面的重新加载（再次让浏览器为我们做更多事情）：源码模块的请求会根据 "),_("code",[v._v("304 Not Modified")]),v._v(" 进行协商缓存，而依赖模块请求则会通过 "),_("code",[v._v("Cache-Control: max-age=31536000,immutable")]),v._v(" 进行强缓存，因此一旦被缓存它们将不需要再次请求。")]),v._v(" "),_("p",[v._v("一旦你体验到 "),_("code",[v._v("Vite")]),v._v(" 的神速，你是否愿意再忍受像曾经那样使用打包器开发就要打上一个大大的问号了。")]),v._v(" "),_("h3",{attrs:{id:"为什么生产环境仍需打包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为什么生产环境仍需打包"}},[v._v("#")]),v._v(" 为什么生产环境仍需打包#")]),v._v(" "),_("p",[v._v("尽管原生 "),_("code",[v._v("ESM")]),v._v(" 现在得到了广泛支持，但由于嵌套导入会导致额外的网络往返，在生产环境中发布未打包的 "),_("code",[v._v("ESM")]),v._v(" 仍然效率低下（即使使用 "),_("code",[v._v("HTTP/2")]),v._v("）。为了在生产环境中获得最佳的加载性能，最好还是将代码进行 "),_("code",[v._v("tree-shaking")]),v._v("、懒加载和 "),_("code",[v._v("chunk")]),v._v(" 分割（以获得更好的缓存）。")]),v._v(" "),_("p",[v._v("要确保开发服务器和生产环境构建之间的最优输出和行为一致并不容易。所以 Vite 附带了一套 构建优化 的 构建命令，开箱即用。")]),v._v(" "),_("h3",{attrs:{id:"为何不用-esbuild-打包"}},[_("a",{staticClass:"header-anchor",attrs:{href:"#为何不用-esbuild-打包"}},[v._v("#")]),v._v(" 为何不用 ESBuild 打包？#")]),v._v(" "),_("p",[v._v("虽然 "),_("code",[v._v("esbuild")]),v._v(" 快得惊人，并且已经是一个在构建库方面比较出色的工具，但一些针对构建 应用 的重要功能仍然还在持续开发中 —— 特别是代码分割和 CSS 处理方面。就目前来说，Rollup 在应用打包方面更加成熟和灵活。尽管如此，当未来这些功能稳定后，我们也不排除使用 "),_("code",[v._v("esbuild")]),v._v(" 作为生产构建器的可能。")])])}),[],!1,null,null,null);_.default=c.exports}}]);